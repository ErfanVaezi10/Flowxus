# -*- coding: utf-8 -*-
# Flowxus/mesh/core/assembler.py

"""
Project: Flowxus
Author: Erfan Vaezi
Date: 11/28/2025

Purpose:
--------
Gmsh-specific assembly logic extracted from writer.py. Handles the combination of
geometry, fields, and meshing controls into complete .geo scripts.

Main Tasks:
-----------
    1. Integrate geometry definitions with mesh sizing fields
    2. Apply Gmsh-specific meshing controls and algorithms
    3. Assemble complete .geo script text from components
    4. Handle Gmsh-specific formatting and syntax

Notes:
------
- This module contains Gmsh-specific assembly logic
- Focuses purely on text assembly - no validation or processing
- Designed to work with processed data from processor.py
"""

from typing import Dict, Any
import io
from geometry.geo.geo_writer import emit_geometry_only_geo
from .fields import emit_sizing_fields


def assemble_geo_script(processed_data: Dict[str, Any]) -> str:
    """
    Assemble complete Gmsh .geo script from processed domain data.

    Parameters
    ----------
    processed_data : Dict[str, Any]
        Processed domain data from processor.py

    Returns
    -------
    str
        Complete Gmsh .geo script text

    Notes
    -----
    This function is Gmsh-specific and focuses on text assembly
    without any validation or data processing.
    """
    # Extract processed data
    airfoil_pts_closed = processed_data['airfoil_points_closed']
    bbox = processed_data['bounding_box']
    physical_tags = processed_data['physical_tags']
    chord_scale = processed_data['chord_scale']
    point_sizes = processed_data['airfoil_point_sizes']
    inflation_settings = processed_data['inflation_settings']
    mesh_size_settings = processed_data['mesh_size_settings']
    thickness = processed_data['thickness']
    distance_points_per_curve = processed_data['distance_points_per_curve']
    dist_min = processed_data['dist_min']
    dist_max = processed_data['dist_max']
    edge_dist_min = processed_data['edge_dist_min']
    edge_dist_max = processed_data['edge_dist_max']
    hybrid_bl_eff = processed_data['hybrid_bl']

    # --- Assemble final .geo ---
    buf = io.StringIO()
    W = buf.write
    W("// ===== AUTO-GENERATED BY mesh.gmsh.writer =====\n\n")

    # 1) Geometry first
    geo_txt = emit_geometry_only_geo(
        airfoil_points_closed=airfoil_pts_closed,
        bbox=bbox,
        physical_tags=physical_tags,
    )
    W(geo_txt)
    W("\n")

    # 2) Then fields
    fields_txt = emit_sizing_fields(
        inflation_settings=inflation_settings,
        mesh_size_settings=mesh_size_settings,
        chord_scale=chord_scale,
        thickness=thickness,
        distance_points_per_curve=distance_points_per_curve,
        dist_min=dist_min,
        dist_max=dist_max,
        edge_dist_min=edge_dist_min,
        edge_dist_max=edge_dist_max,
        hybrid_bl=hybrid_bl_eff,
        airfoil_curve_id=1,  # Spline id from geo_writer
        airfoil_point_sizes=point_sizes,
        fan_node_ids=[1],  # assume Point(1) is TE; adjust if needed
    )
    W(fields_txt)
    W("\n")

    # 3) Right before meshing, enforce triangle-friendly global options.
    #    The BL field will still create quads locally along the airfoil.
    if hybrid_bl_eff:
        # Use a TRIANGULAR surface algorithm; BL will still create quads locally
        # 6 = Frontal-Delaunay (triangles), 5 = Delaunay (triangles)
        W("Mesh.Algorithm = 6;\n")
        W("Mesh.RecombineAll = 0;\n")  # do NOT globally recombine
        # (Intentionally no 'Recombine Surface {100};' here)
        W("Mesh.Optimize = 1;\n")
        W("Mesh.CharacteristicLengthExtendFromBoundary = 0;\n")
        W("\n")

    # 4) Generate 2D mesh
    W("Mesh 2;\n")

    return buf.getvalue()
